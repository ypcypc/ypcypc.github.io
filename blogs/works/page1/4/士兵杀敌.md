#士兵杀敌

---

##RMQ
这道题目一搭眼就能看出来是RMQ（有看不出来是RMQ的同学吗），如果还不会RMQ请[单击此处](https://baike.baidu.com/item/rmq/1797559?fr=aladdin)。我们可以构造两个数组mn和mx分别表示区域间的最小杀敌数和最大杀敌数。
那么我们就可以轻松地解掉了
附上代码：

    #include<cstdio>
    #include<cmath>
    #include<algorithm>
    using namespace std;
    const int maxl=log2(100005);
    inline int read(){
    	int ret=0;char ch=getchar();
    	while (ch<'0'||ch>'9')ch=getchar();
    	while (ch>='0'&&ch<='9')ret=ret*10+ch-48,ch=getchar();
    	return ret;
    }
    int n,q,fmx[100005][maxl+1],fmn[100005][maxl+1];
    inline void RMQ(){
    	for (int j=1;j<=log2(n);j++)
    	for (int i=1;i<=n-(1<<j)+1;i++)
    	fmx[i][j]=max(fmx[i][j-1],fmx[i+(1<<(j-1))][j-1]),
		fmn[i][j]=min(fmn[i][j-1],fmn[i+(1<<(j-1))][j-1]);
    }
    inline int getans(int L,int R){
    	int k=log2(R-L+1),mx,mn;
    	mx=max(fmx[L][k],fmx[R-(1<<k)+1][k]),
    	mn=min(fmn[L][k],fmn[R-(1<<k)+1][k]);
    	return mx-mn;
    }
	int main(){
		freopen("soldier.in","r",stdin);
		freopen("soldier.out","w",stdout);
		n=read(),q=read();
		for (int i=1;i<=n;i++){
			int x=read();
			fmx[i][0]=x,fmn[i][0]=x;
		}
		RMQ();
		for (int i=1;i<=q;i++){
			int L=read(),R=read();
			printf("%d\n",getans(L,R));
		}
		return 0;
	}
但是呢，这道题目其实完全可以换个思路去解

##线段树
我们都知道线段树的功能是很多很多的，包括这区间求极值的基本作用，如果有不会线段树的帅哥可以参考[线段树](https://baike.baidu.com/item/%E7%BA%BF%E6%AE%B5%E6%A0%91/10983506?fr=aladdin)，我们可以构造两个线段树，分别表示区间最大（st.mx）和区间最小(st.mn)，然后2*log N的查找就可以了